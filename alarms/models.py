from django.db import models
from utils.choice_enum import ChoiceEnum
import time


class OperationalMode(ChoiceEnum):
    """ Operational Mode of a monitor point value. """

    STARTUP = 0
    INITIALIZATION = 1
    CLOSING = 2
    SHUTTEDDOWN = 3
    MAINTENANCE = 4
    OPERATIONAL = 5
    DEGRADED = 6
    UNKNOWN = 7

    @classmethod
    def options(cls):
        """ Return a list of tuples with the valid options. """
        return cls.get_choices()


class Validity(ChoiceEnum):
    """ Possible validity states of an Alarm """

    RELIABLE = 1
    """ The value has been provided in time and the operator can trust what
    the IAS shows"""

    UNRELIABLE = 0
    """ The values has not been produced in time either by the IAS Core or due
    to network problems or any other reason."""

    @classmethod
    def options(cls):
        """ Returns a list of tuples with the valid options. """
        return cls.get_choices()

    @classmethod
    def refresh_rate(cls):
        """ Returns a refresh_rate in milliseconds defined to be used to
        calculate the validity of alarms """
        return 5000

    @classmethod
    def delta(cls):
        """ Returns a delta of time in milliseconds defined to be used as
        error margin for the calculation of validity """
        return 500


class Alarm(models.Model):
    """ Alarm generated by some device in the observatory. """

    value = models.IntegerField(default=0, blank=False, null=False)
    """ Integer that indicates the alarm. Can be either 0 (CLEARED) or 1 (SET
    or raised). """

    mode = models.CharField(
        max_length=1, choices=OperationalMode.options(),
        blank=False, null=False, default=0
    )
    """ Operational Mode of a monitor point value. """

    core_timestamp = models.PositiveIntegerField(blank=False, null=False)
    """ Timestamp inherited from IAS core processing. It correspond to the time
    when the value has been read from the remote system.
    """

    core_id = models.CharField(
        max_length=100, blank=False, null=False, db_index=True
    )
    """ Id used to identify the Alarm in the IAS Core. """

    running_id = models.CharField(max_length=100, blank=False, null=False)
    """ Id used to identify the Alarm and its parents in the IAS Core. """

    validity = models.CharField(
        max_length=1, choices=Validity.options(),
        blank=False, null=False, default=0
    )
    """ Validity of the alarm. """

    pluginProductionTStamp = models.CharField(
        max_length=22, blank=False, null=True
    )

    sentToConverterTStamp = models.CharField(
        max_length=22, blank=False, null=True
    )

    receivedFromPluginTStamp = models.CharField(
        max_length=22, blank=False, null=True
    )

    convertedProductionTStamp = models.CharField(
        max_length=22, blank=False, null=True
    )

    sentToBsdbTStamp = models.CharField(
        max_length=22, blank=False, null=True
    )

    readFromBsdbTStamp = models.CharField(
        max_length=22, blank=False, null=True
    )

    dasuProductionTStamp = models.CharField(
        max_length=22, blank=False, null=True
    )

    def __str__(self):
        """ Returns a string representation of the object """

        return str(self.core_id) + '=' + str(self.value)

    def to_dict(self):
        return {
            'value': self.value,
            'mode': self.mode,
            'validity': self.validity,
            'core_timestamp': self.core_timestamp,
            'core_id': self.core_id,
            'running_id': self.running_id
        }

    def equals_except_timestamp(self, alarm):
        """
        Check if the attributes of the alarm are different to the values
        retrieved in params, the verification does not consider the
        core_timestamp value.
        """
        for key in self._meta.get_fields():
            field = key.name
            if field == 'core_timestamp' or field == 'id' or field == 'pk':
                continue
            self_attribute = getattr(self, field)
            alarm_attribute = getattr(alarm, field)
            if self_attribute != alarm_attribute:
                return False
        return True

    def check_changes(self, params):
        """
        Check if the attributes of the alarm are different to the values
        retrieved in params, the verification does not consider the
        core_timestamp value.
        """
        changes = False
        for key, value in params.items():
            if key != 'core_timestamp' and getattr(self, key) != value:
                changes = True
        return changes

    def update_ignoring_timestamp(self, params):
        """
        Updates the alarm with the values given in a dict,
        according to some conditions.

        Args:
            params (dict): Dictionary of values indexed by parameter names

        Returns:
            bool: True if the alarm was updated, False if not
        """
        # Update core_timestamp:
        self.core_timestamp = params['core_timestamp']

        # Update the rest of the attributes only if they are different:
        update = False
        for key, value in params.items():
            if key == 'core_timestamp':
                continue
            if getattr(self, key) != value:
                setattr(self, key, value)
                update = True

        # Save changes only if there was a different attribute (except core_id)
        if update:
            super(Alarm, self).save()
            return True
        return False

    def update_validity(self):
        """
        Calculate the validity of the alarm considering the current time,
        the refresh rate and a previously defined delta time
        """
        if self.validity == '0':
            return self
        refresh_rate = Validity.refresh_rate()
        delta = Validity.delta()
        current_timestamp = int(round(time.time() * 1000))
        if current_timestamp - self.core_timestamp > refresh_rate + delta:
            self.validity = '0'
            return self
        else:
            return self
