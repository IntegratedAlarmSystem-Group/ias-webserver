from django.db import models
from channels.binding.websockets import WebsocketBinding
from utils.choice_enum import ChoiceEnum

from channels import Group

# Always keep models and bindings in this file!!


class OperationalMode(ChoiceEnum):
    """ Operational Mode of a monitor point value. """

    STARTUP = 0
    INITIALIZATION = 1
    CLOSING = 2
    SHUTTEDOWN = 3
    MAINTENANCE = 4
    OPERATIONAL = 5
    DEGRADED = 6
    UNKNOWN = 7

    @classmethod
    def options(cls):
        """ Return a list of tuples with the valid options. """
        return cls.get_choices()


class Alarm(models.Model):
    """ Alarm generated by some device in the observatory. """

    value = models.IntegerField(default=0, blank=False, null=False)
    """ Integer that indicates the alarm. Can be either 0 (CLEARED) or 1 (SET
    or raised). """

    mode = models.CharField(
        max_length=1, choices=OperationalMode.options(),
        blank=False, null=False, default=0
    )
    """ Operational Mode of a monitor point value. """

    core_timestamp = models.PositiveIntegerField(blank=False, null=False)
    """ Timestamp inherited from IAS core processing. It correspond to the time
    when the value has been read from the remote system.
    """

    core_id = models.CharField(
        max_length=100, blank=False, null=False, db_index=True
    )
    """ Id used to identify the Alarm in the IAS Core. """

    running_id = models.CharField(max_length=100, blank=False, null=False)
    """ Id used to identify the Alarm and its parents in the IAS Core. """

    def __str__(self):
        """ Returns a string representation of the object """

        return str(self.core_id) + '=' + str(self.value)

    def check_changes(self, params):
        """
        Check if the attributes of the alarm are different to the values
        retrieved in params, the verification does not consider the
        core_timestamp value.
        """
        changes = False
        for key, value in params.items():
            if key != 'core_timestamp' and getattr(self, key) != value:
                changes = True
        return changes

    def update_ignoring_timestamp(self, params):
        """
        Updates the alarm with the values given in a dict,
        according to some conditions.

        Args:
            params (dict): Dictionary of values indexed by parameter names

        Returns:
            bool: True if the alarm was updated, False if not
        """
        # Update core_timestamp:
        self.core_timestamp = params['core_timestamp']

        # Update the rest of the attributes only if they are different:
        update = False
        del params['core_timestamp']
        for key, value in params.items():
            if getattr(self, key) != value:
                setattr(self, key, value)
                update = True

        # Save changes only if there was a different attribute (except core_id)
        if update:
            super(Alarm, self).save()
            return True
        return False


class AlarmBinding(WebsocketBinding):
    """ Bind the alarm actions with a websocket stream. """

    model = Alarm
    """ Model binded with the websocket """

    stream = "alarms"
    """ Name of the stream to send the messages. """

    fields = ["__all__"]
    """ List of fields included in the messages. """

    messages_replication_factor = 3
    """ Number of replicated messages after a required action """

    @classmethod
    def group_names(cls, *args, **kwargs):
        """ Return a list of the groups that receive the binding messages. """

        return ["alarms_group"]

    def has_permission(self, user, action, pk):
        """ Return if the user has permission to make the specified action. """

        return True

    def send_messages(self, instance, group_names, action, **kwargs):
        """
        Serializes the instance and sends it to all provided group names.
        """

        if not group_names:
            return  # no need to serialize, bail.
        self.signal_kwargs = kwargs
        payload = self.serialize(instance, action)
        if payload == {}:
            return  # nothing to send, bail.

        assert self.stream is not None
        message = self.encode(self.stream, payload)

        for group_name in group_names:
            group = Group(group_name)
            group.send(message)

            if payload['action'] == 'create':
                for k in range(self.messages_replication_factor):
                    group.send(message)
